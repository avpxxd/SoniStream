<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SonicStream Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;600&display=swap');
        
        body {
            font-family: 'Space Grotesk', sans-serif;
            background-color: #050505;
            color: white;
            overflow: hidden; /* Prevent scrollbars */
        }

        /* Custom Scrollbar for file list if needed later */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #111; 
        }
        ::-webkit-scrollbar-thumb {
            background: #444; 
            border-radius: 4px;
        }

        .glass-panel {
            background: rgba(20, 20, 20, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-layer {
            position: relative;
            z-index: 10;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            pointer-events: none; /* Let clicks pass through to canvas if needed */
        }

        .interactive {
            pointer-events: auto;
        }

        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: rgba(255, 255, 255, 0.2); /* Fallback */
            height: 4px;
            border-radius: 2px;
            cursor: pointer;
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -6px; /* Center thumb on the 4px track */
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
            position: relative;
            z-index: 2;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: transparent; /* Track is transparent so input background shows through */
            border-radius: 2px;
            border: none;
        }
    </style>
</head>
<body>

    <!-- Main Canvas -->
    <canvas id="visualizer-canvas"></canvas>

    <!-- UI Overlay -->
    <div id="ui-layer">
        
        <!-- Header -->
        <header class="p-6 flex justify-between items-start interactive">
            <div>
                <h1 class="text-3xl font-bold tracking-tighter bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-600">
                    SONIC<span class="font-light text-white">STREAM</span>
                </h1>
                <p id="status-text" class="text-xs text-gray-400 mt-1 uppercase tracking-widest">Waiting for input...</p>
            </div>
            
            <!-- Visualizer Mode Selector -->
            <div class="glass-panel rounded-full p-1 flex space-x-1 relative">
                <!-- Sliding Pill Background -->
                <div id="selector-pill" class="absolute bg-white rounded-full transition-all duration-300 ease-out shadow-sm" style="opacity: 0;"></div>
                
                <!-- Buttons -->
                <button onclick="setVisualizerMode('bars')" id="btn-bars" class="relative z-10 px-4 py-2 rounded-full text-sm font-medium transition-colors duration-300">Bars</button>
                <button onclick="setVisualizerMode('radial')" id="btn-radial" class="relative z-10 px-4 py-2 rounded-full text-sm font-medium transition-colors duration-300">Radial</button>
                <button onclick="setVisualizerMode('particles')" id="btn-particles" class="relative z-10 px-4 py-2 rounded-full text-sm font-medium transition-colors duration-300">Particles</button>
            </div>
        </header>

        <!-- Center Message (Initial State) -->
        <div id="start-overlay" class="absolute inset-0 flex items-center justify-center interactive bg-black/50 backdrop-blur-sm transition-opacity duration-500">
            <div class="text-center">
                <div class="mb-6 text-6xl text-purple-500 animate-pulse">
                    <i class="fa-solid fa-headphones-simple"></i>
                </div>
                <h2 class="text-2xl font-bold mb-4">Start Visualizer</h2>
                <div class="flex gap-4 justify-center">
                    <button onclick="initMicrophone()" class="px-6 py-3 bg-blue-600 hover:bg-blue-500 rounded-lg font-bold transition flex items-center gap-2 shadow-lg shadow-blue-900/50">
                        <i class="fa-solid fa-microphone"></i> Use Microphone
                    </button>
                    <label class="px-6 py-3 bg-purple-600 hover:bg-purple-500 rounded-lg font-bold transition flex items-center gap-2 cursor-pointer shadow-lg shadow-purple-900/50">
                        <i class="fa-solid fa-file-audio"></i> Upload File
                        <input type="file" id="file-input" accept="audio/*" class="hidden" onchange="handleFileUpload(this)">
                    </label>
                </div>
            </div>
        </div>

        <!-- Bottom Controls -->
        <div class="p-6 interactive">
            <div class="glass-panel rounded-2xl p-4 max-w-2xl mx-auto w-full">
                
                <!-- Track Info & Time -->
                <div class="flex justify-between text-xs text-gray-400 mb-2">
                    <span id="track-name">No track playing</span>
                    <span id="track-time">0:00 / 0:00</span>
                </div>

                <!-- Progress Bar (File Mode Only) -->
                <div class="mb-4 relative group">
                    <input type="range" id="seek-slider" min="0" max="100" value="0" disabled oninput="seekAudio(this.value)">
                </div>

                <!-- Controls Row -->
                <div class="flex items-center justify-between">
                    <!-- Volume -->
                    <div class="flex items-center gap-3 w-1/3">
                        <button onclick="toggleMute()" class="text-gray-300 hover:text-white">
                            <i id="vol-icon" class="fa-solid fa-volume-high"></i>
                        </button>
                        <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.8" oninput="setVolume(this.value)" class="w-24">
                    </div>

                    <!-- Play/Pause & Mode Switch -->
                    <div class="flex items-center gap-6 justify-center w-1/3">
                        <button id="play-btn" onclick="togglePlay()" class="w-12 h-12 rounded-full bg-white text-black flex items-center justify-center hover:scale-105 transition disabled:opacity-50" disabled>
                            <i class="fa-solid fa-play"></i>
                        </button>
                    </div>

                    <!-- Upload Button (Mini) -->
                    <div class="flex items-center justify-end gap-4 w-1/3">
                        <button id="loop-btn" onclick="toggleLoop()" class="text-gray-400 hover:text-white text-sm transition" title="Loop Track">
                            <i class="fa-solid fa-repeat"></i> Loop
                        </button>
                         <button onclick="document.getElementById('file-input').click()" class="text-gray-300 hover:text-white text-sm">
                            <i class="fa-solid fa-upload"></i> Change File
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration & State ---
        let audioContext;
        let audioSource;
        let analyser;
        let gainNode;
        let audioElement; // For file playback
        
        let isMicMode = false;
        let isPlaying = false;
        let isLooping = false;
        let animationId;
        
        // Canvas Setup
        const canvas = document.getElementById('visualizer-canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        // Visualizer State
        let currentMode = 'bars'; // 'bars', 'radial', 'particles'
        let dataArray, bufferLength;
        
        // Particles for Particle Mode
        let particles = [];

        // --- Initialization ---

        // Helper to update slider fill (white to left, transparent to right)
        function updateRangeBackground(el) {
            const min = parseFloat(el.min) || 0;
            const max = parseFloat(el.max) || 100;
            const val = parseFloat(el.value) || 0;
            const percentage = ((val - min) / (max - min)) * 100;
            el.style.background = `linear-gradient(to right, #ffffff ${percentage}%, rgba(255,255,255,0.2) ${percentage}%)`;
        }

        // Initialize sliders and visualizer mode on load
        window.addEventListener('DOMContentLoaded', () => {
             const vol = document.getElementById('volume-slider');
             if(vol) updateRangeBackground(vol);
             const seek = document.getElementById('seek-slider');
             if(seek) updateRangeBackground(seek);
             
             // Initialize Visualizer Mode Selector
             setTimeout(() => setVisualizerMode('bars'), 100); // Small delay ensures layout is ready
        });

        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048; // Resolution of frequency data
                
                // Smoothing makes the movement less jittery
                analyser.smoothingTimeConstant = 0.85;

                gainNode = audioContext.createGain();
                gainNode.gain.value = 0.8;
                
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
            }
            // Resume context if suspended (browser policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // --- Input Handling ---

        async function initMicrophone() {
            try {
                initAudioContext();
                stopCurrentAudio();
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioSource = audioContext.createMediaStreamSource(stream);
                // Mic input goes to analyser ONLY, not destination (to prevent feedback loop)
                audioSource.connect(analyser);
                
                isMicMode = true;
                isPlaying = true;
                
                document.getElementById('start-overlay').style.opacity = '0';
                setTimeout(() => document.getElementById('start-overlay').style.display = 'none', 500);
                
                updateUIState(true, "Microphone Input");
                startVisualizer();
            } catch (err) {
                alert("Microphone access denied or error: " + err.message);
            }
        }

        function handleFileUpload(input) {
            if (input.files.length === 0) return;
            const file = input.files[0];
            const objectUrl = URL.createObjectURL(file);
            
            initAudioContext();
            stopCurrentAudio();

            audioElement = new Audio();
            audioElement.src = objectUrl;
            audioElement.crossOrigin = "anonymous";
            audioElement.loop = isLooping;
            
            // Link audio element to Web Audio API
            audioSource = audioContext.createMediaElementSource(audioElement);
            // File audio goes to analyser AND speakers
            audioSource.connect(analyser);
            analyser.connect(gainNode);
            gainNode.connect(audioContext.destination);

            audioElement.onended = () => {
                isPlaying = false;
                updatePlayButton();
            };
            
            audioElement.ontimeupdate = updateProgress;

            // Start playing
            audioElement.play().then(() => {
                isMicMode = false;
                isPlaying = true;
                
                document.getElementById('start-overlay').style.opacity = '0';
                setTimeout(() => document.getElementById('start-overlay').style.display = 'none', 500);
                
                updateUIState(true, file.name);
                startVisualizer();
            }).catch(e => console.error("Playback failed:", e));
        }

        function stopCurrentAudio() {
            if (audioSource) {
                audioSource.disconnect();
            }
            if (audioElement) {
                audioElement.pause();
                audioElement.src = "";
                audioElement = null;
            }
            cancelAnimationFrame(animationId);
        }

        // --- Controls ---

        function togglePlay() {
            if (!audioContext) return;
            
            if (isMicMode) {
                // For mic, play/pause just stops visualization logic mostly
                if (audioContext.state === 'running') {
                    audioContext.suspend();
                    isPlaying = false;
                } else {
                    audioContext.resume();
                    isPlaying = true;
                }
            } else if (audioElement) {
                if (audioElement.paused) {
                    audioElement.play();
                    isPlaying = true;
                } else {
                    audioElement.pause();
                    isPlaying = false;
                }
            }
            updatePlayButton();
        }

        function setVolume(val) {
            if (gainNode) {
                gainNode.gain.value = val;
            }
            
            // Update Icon
            const icon = document.getElementById('vol-icon');
            if(val == 0) icon.className = "fa-solid fa-volume-off";
            else if(val < 0.5) icon.className = "fa-solid fa-volume-low";
            else icon.className = "fa-solid fa-volume-high";

            // Update Slider Fill
            const slider = document.getElementById('volume-slider');
            if (slider) {
                // If this was called programmatically (not by drag), update value
                if (slider.value != val) slider.value = val;
                updateRangeBackground(slider);
            }
        }

        function toggleMute() {
            const slider = document.getElementById('volume-slider');
            let newVal;
            
            if(gainNode.gain.value > 0) {
                newVal = 0;
            } else {
                newVal = 0.8;
            }
            
            setVolume(newVal);
        }

        function updateProgress() {
            if (!audioElement) return;
            const progress = (audioElement.currentTime / audioElement.duration) * 100;
            const slider = document.getElementById('seek-slider');
            
            if(slider) {
                slider.value = progress || 0;
                updateRangeBackground(slider);
            }
            
            // Format time
            const curMins = Math.floor(audioElement.currentTime / 60);
            const curSecs = Math.floor(audioElement.currentTime % 60);
            const durMins = Math.floor(audioElement.duration / 60) || 0;
            const durSecs = Math.floor(audioElement.duration % 60) || 0;
            
            document.getElementById('track-time').innerText = 
                `${curMins}:${curSecs < 10 ? '0'+curSecs : curSecs} / ${durMins}:${durSecs < 10 ? '0'+durSecs : durSecs}`;
        }

        function seekAudio(val) {
            if (!audioElement) return;
            const time = (val / 100) * audioElement.duration;
            audioElement.currentTime = time;
            
            const slider = document.getElementById('seek-slider');
            updateRangeBackground(slider);
        }

        function toggleLoop() {
            isLooping = !isLooping;
            
            if (audioElement) {
                audioElement.loop = isLooping;
            }

            const btn = document.getElementById('loop-btn');
            if (isLooping) {
                btn.classList.remove('text-gray-400');
                btn.classList.add('text-blue-400', 'font-bold');
            } else {
                btn.classList.add('text-gray-400');
                btn.classList.remove('text-blue-400', 'font-bold');
            }
        }

        // --- UI Updates ---

        function updateUIState(playing, trackName) {
            document.getElementById('play-btn').disabled = false;
            document.getElementById('seek-slider').disabled = isMicMode;
            document.getElementById('status-text').innerText = isMicMode ? "Listening..." : "Playing";
            if (trackName) document.getElementById('track-name').innerText = trackName.length > 30 ? trackName.substring(0, 30) + "..." : trackName;
            updatePlayButton();
        }

        function updatePlayButton() {
            const btn = document.getElementById('play-btn');
            btn.innerHTML = isPlaying ? '<i class="fa-solid fa-pause"></i>' : '<i class="fa-solid fa-play"></i>';
        }

        function setVisualizerMode(mode) {
            currentMode = mode;
            
            const modes = ['bars', 'radial', 'particles'];
            const pill = document.getElementById('selector-pill');
            
            modes.forEach(m => {
                const btn = document.getElementById(`btn-${m}`);
                if (m === mode) {
                    // Active State
                    btn.classList.remove('text-gray-400', 'hover:text-white');
                    btn.classList.add('text-black');
                    
                    // Move Pill
                    if (pill) {
                        pill.style.opacity = '1';
                        pill.style.width = `${btn.offsetWidth}px`;
                        pill.style.height = `${btn.offsetHeight}px`;
                        pill.style.left = `${btn.offsetLeft}px`;
                        pill.style.top = `${btn.offsetTop}px`;
                    }
                } else {
                    // Inactive State
                    btn.classList.remove('text-black');
                    btn.classList.add('text-gray-400', 'hover:text-white');
                }
            });

            // Reset particles if switching away
            if(mode !== 'particles') particles = [];
        }

        // --- Visualizer Engines ---

        function startVisualizer() {
            function draw() {
                animationId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);

                // Clear Canvas
                ctx.fillStyle = 'rgba(5, 5, 5, 0.2)'; // Trail effect
                ctx.fillRect(0, 0, width, height);

                if (currentMode === 'bars') drawBars();
                else if (currentMode === 'radial') drawRadial();
                else if (currentMode === 'particles') drawParticles();
            }
            draw();
        }

        function drawBars() {
            const barCount = 150; // Don't use full buffer, 1024 bars is too many for pixels
            const barWidth = (width / barCount);
            let x = 0;

            for (let i = 0; i < barCount; i++) {
                // Mapping i to frequency data roughly
                // We focus on lower 2/3rds of spectrum usually
                const index = Math.floor(i * (bufferLength / barCount) * 0.8); 
                const value = dataArray[index];
                
                const barHeight = (value / 255) * height * 0.8;
                
                // Color based on frequency
                const hue = i * 2 + (value / 4);
                ctx.fillStyle = `hsl(${hue}, 80%, 50%)`;
                
                // Draw rounded top bar
                ctx.beginPath();
                ctx.roundRect(x, height - barHeight, barWidth - 2, barHeight, [5, 5, 0, 0]);
                ctx.fill();

                // Reflection
                ctx.fillStyle = `hsla(${hue}, 80%, 50%, 0.1)`;
                ctx.fillRect(x, height, barWidth - 2, barHeight * 0.3);

                x += barWidth;
            }
        }

        function drawRadial() {
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 4;
            const bars = 100;
            const step = (Math.PI * 2) / bars;

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 10, 0, Math.PI * 2);
            ctx.fillStyle = '#000';
            ctx.fill();

            for (let i = 0; i < bars; i++) {
                const index = Math.floor(i * (bufferLength / bars) * 0.5); 
                const value = dataArray[index];
                const barHeight = (value / 255) * (Math.min(width, height) / 3);
                
                const angle = i * step;
                
                // Start point (on circle)
                const startX = centerX + Math.cos(angle) * radius;
                const startY = centerY + Math.sin(angle) * radius;
                
                // End point
                const endX = centerX + Math.cos(angle) * (radius + barHeight);
                const endY = centerY + Math.sin(angle) * (radius + barHeight);

                const hue = (i / bars) * 360 + (value / 2);

                ctx.strokeStyle = `hsl(${hue}, 70%, 60%)`;
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }

            // Center glow based on bass
            const bassAvg = dataArray.slice(0, 10).reduce((a, b) => a + b, 0) / 10;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.8, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${bassAvg}, 70%, 50%, 0.2)`;
            ctx.fill();
        }

        class Particle {
            constructor(x, y, vx, vy, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = 100;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 2;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life / 100;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        function drawParticles() {
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Analyze bass for thumping effect
            const bass = dataArray.slice(0, 5).reduce((a, b) => a + b, 0) / 5;
            const scale = 1 + (bass / 255) * 0.5;

            // Draw central pulsating orb
            ctx.beginPath();
            ctx.arc(centerX, centerY, 50 * scale, 0, Math.PI * 2);
            ctx.fillStyle = `hsl(${bass}, 80%, 50%)`;
            ctx.shadowBlur = 50;
            ctx.shadowColor = `hsl(${bass}, 80%, 50%)`;
            ctx.fill();
            ctx.shadowBlur = 0;

            // Spawn particles on beats (high bass threshold)
            if (bass > 200) {
                for (let i = 0; i < 5; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 2;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    particles.push(new Particle(centerX, centerY, vx, vy, `hsl(${Math.random() * 360}, 100%, 70%)`));
                }
            }

            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw(ctx);
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

    </script>
</body>
</html>
